// Metadata created by nebel

[id="intro-to-registry"]
= Registry overview

Apicurio Registry is a datastore for standard event schemas and API designs. It enables developers to share and manage the structure of their data using a REST interface. For example, client applications can dynamically pull the latest updates from the registry at runtime without needing to redeploy. 

Apicurio Registry also enables developers to create rules to govern how the registry content can evolve over time. For example, this includes rules for content validation and version compatibility.

.Supported artifact types
The supported artifact format types that the registry can store are:

[%header,cols=2*] 
|===
|Type
|Description
|`AVRO`
|Apache Avro schema
|`PROTOBUF`
|Google protocol buffers schema 
|`JSON`
|JSON Schema
|`OPENAPI`
|OpenAPI specification
|`ASYNCAPI`
|AsyncAPI specification
|===

.Storage implementations
Apicurio Registry provides pluggable storage implementations with the following options: 

* In-memory 
* Java Persistence API 
* Apache Kafka 
* Apache Kafka Streams

NOTE: The default in-memory storage option is suitable for a development environment only. All data is lost when using the in-memory storage option. All other storage options are  suitable for development and production environments.

For more details, see https://github.com/Apicurio/apicurio-registry. 

.Apicurio Registry REST API
The Apicurio Registry REST API enables client applications to manage the artifacts in the registry. It provides create, read, update, and delete operations for schema and API artifacts, rules, versions, and metadata. 

For more details, see the link:files/index.html[Apicurio Registry REST API documentation]

= Rules for registry content
You can configure rules for each artifact added to the registry to govern content evolution in the registry. All of the rules configured for an artifact must pass before a new version can be uploaded. 

The goal of these rules is to prevent invalid content from being added to the registry. For example, content can be invalid for a number of reasons:

* Invalid syntax for a given artifact type
* Valid syntax but semantics violate company standards
* New content makes breaking changes compared with the current version

.When rules are applied
Rules are applied only when content is added to the registry. This includes the following REST operations:

* Creating an artifact
* Updating an artifact
* Creating an artifact version

If a rule is violated, Apicurio Registry will return an HTTP error. The response body will include the violated rule and a message showing what went wrong.

NOTE: If no rules are configured for a particular artifact, the set of global rules will be applied.  This means that the global rules are always applied when a new artifact is created.  

.How rules work
Every rule is simply a name and optionally some configuration. The storage layer maintains a list of the rules for each artifact, as well as a list of global rules. Each rule in that list consists of a name and set of configuration properties (for example, `Map<String,String>`).

A rule is provided with the content of the current version of the artifact and the new version of the content being added. The rule implementation will return true or false depending on whether it passes. If not, the rule will report thereason why by the REST layer in an HTTP error response.

Some rules may not use the previous version of the content. For example, compatibility rules will, but validity (syntax and semantic) rules most likely will not.

.Supported rule types
You can specify the following rule types to govern content evolution in the registry: 

[%header,cols=2*] 
|===
|Type
|Description
|`VALIDITY`
| Validate the data before adding it to the registry. The validation can be syntax only or syntax and semantic (FULL validation). 
|`COMPATIBILITY` 
|Ensure that artifacts are backwards/forwards compatible with other versions.
|===
